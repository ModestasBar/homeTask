{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///webpack/bootstrap bcb4aa70760565eced86?f838","webpack:///./~/shortid/lib/alphabet.js?cd47","webpack:///./~/shortid/index.js?5ae0","webpack:///./~/msgr/index.js?2c45","webpack:///./~/serialise-request/dist/serialise-request.min.js?44a5","webpack:///./~/serialise-response/index.js?fad1","webpack:///./~/msgr/~/mini-defer/index.js?1d44","webpack:///./~/shortid/lib/decode.js?7cfd","webpack:///./~/shortid/lib/encode.js?f2df","webpack:///./~/shortid/lib/index.js?00f7","webpack:///./~/shortid/lib/is-valid.js?f445","webpack:///./~/shortid/lib/random/random-byte-browser.js?6acb","webpack:///./~/shortid/lib/random/random-from-seed.js?547f","webpack:///./~/shortid/lib/util/cluster-worker-id-browser.js?cb43","webpack:///./~/idb-wrapper/idbstore.js","webpack:///C:/xampp/htdocs/fetch-sync/src/worker.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,kDAA0C,WAAW;;AAErD;AACA;AACA;AACA;;;;;;;ACxCA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjGA;AACA;;;;;;;ACDA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,0BAA0B;AACrC,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,0BAA0B;AACrC,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA,oCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AA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B;AACvD;;AAEA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;;AAEA;AACA;AACA,YAAW,cAAc;AACzB;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH,EAAC;AACD;AACA,EAAC;AACD;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;;;;;;AC7FA;;AAEA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;AACD;AACA,EAAC;AACD;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;;;;;;ACpCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChBA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClBA;;AAEA,+EAA8E;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACbA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACxBA;;AAEA;;;;;;;ACFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,MAAM;AACrB;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,MAAM;AACrB,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB;AACrB;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA,cAAa;;AAEb;;AAEA;;AAEA;AACA;AACA,kBAAiB;AACjB,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,0BAAyB;AACzB;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,oBAAmB,EAAE;AACrB;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAwC;AACxC;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,oBAAmB,EAAE;AACrB,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,EAAE;AACrB,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,MAAM;AACzB;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,iDAAgD;AAChD;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,MAAM;AACzB,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA,yBAAwB;AACxB,cAAa;;AAEb;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,MAAM;AACzB,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B;;AAE1B;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA4C;AAC5C;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,oBAAmB,MAAM;AACzB,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA,yBAAwB;AACxB,cAAa;;AAEb;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,MAAM;AACzB,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA,gEAA+D,IAAI;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC,oBAAmB,eAAe;AAClC,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC,oBAAmB,eAAe;AAClC,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,cAAc;AAClC;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,qBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,QAAQ;AAC3B,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B,oBAAmB,OAAO;AAC1B,qBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,QAAQ;AAC3B;AACA,oBAAmB,QAAQ;AAC3B;AACA,oBAAmB,YAAY;AAC/B,oBAAmB,QAAQ;AAC3B;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,QAAQ;AAC3B;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,eAAe;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,QAAQ;AAC3B;AACA,oBAAmB,YAAY;AAC/B,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,YAAY;AAC/B,oBAAmB,SAAS;AAC5B;AACA,sBAAqB,eAAe;AACpC;AACA;;AAEA;AACA;AACA;AACA,cAAa,eAAe;;AAE5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","file":"fetch-sync.sw.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fetchSync\"] = factory();\n\telse\n\t\troot[\"fetchSync\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { throw err; };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 17);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bcb4aa70760565eced86\n **/","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nmodule.exports = {\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/lib/alphabet.js\n ** module id = 0\n ** module chunks = 0 1\n **/","'use strict';\nmodule.exports = require('./lib/index');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/index.js\n ** module id = 1\n ** module chunks = 0 1\n **/","/* global Promise:false, define:false, module:false, self:false, MessageChannel:false */\n\n'use strict'\n\nvar shortid = require('shortid')\nvar defer = require('mini-defer')\n\n// Proxy references for testing\ntry {\n  var _self = self\n  var _MessageChannel = MessageChannel\n} catch (err) {}\n\n// ---\n// API\n// ---\n\n/**\n * Initialise a client or worker to send and receive messages.\n * @param {Object} messageHandlers\n * @param {ServiceWorkerRegistration} worker\n * @returns {Channel}\n */\nfunction msgr (messageHandlers, worker) {\n  return new Channel(messageHandlers, worker)\n}\n\n/**\n * Initialise a worker to send and receive messages to and from the client.\n * @param {Object} messageHandlers\n * @returns {Channel}\n */\nmsgr.worker = function (messageHandlers) {\n  return msgr(messageHandlers, null)\n}\n\n/**\n * Initialise a client to send and receive messages to and from the worker.\n * @param {ServiceWorkerRegistration} worker\n * @param {Object} messageHandlers\n * @returns {Channel}\n */\nmsgr.client = function (worker, messageHandlers, __mockMessageChannel) {\n  _self = __mockMessageChannel ? {} : self\n  _MessageChannel = __mockMessageChannel || MessageChannel\n  return msgr(messageHandlers, worker)\n}\n\n// Reserved message types\nmsgr.types = {\n  CONNECT: '@@MSGR/CONNECT',\n  UNKNOWN: '@@MSGR/UNKNOWN',\n  RESPONSE: '@@MSGR/RESPONSE'\n}\n\n// ---\n// Channel\n// ---\n\nfunction Channel (handlers, worker) {\n  this.handlers = handlers\n  this.isClient = Boolean(worker)\n  this.isWorker = !this.isClient\n\n  // Is the comms channel open?\n  this.open = defer()\n\n  // Handlers for unknown message types\n  this.receiveHandlers = []\n\n  // Deferreds for sent messages so we can resolve\n  // the promise if they receive a response\n  this.promises = {}\n\n  if (this.isClient) {\n    this.open.resolve()\n    this.recipient = worker\n    this.messageChannel = new _MessageChannel()\n    this.messageChannel.port1.onmessage = this._handleMessage.bind(this)\n    this.send(msgr.types.CONNECT)\n  } else {\n    _self.onmessage = this._handleMessage.bind(this)\n  }\n}\n\n/**\n * Handle a message received from the client or worker.\n * @param {Object} event\n * @private\n */\nChannel.prototype._handleMessage = function (event) {\n  try {\n    var request = JSON.parse(event.data)\n    var id = request.id\n    var type = request.type\n    if (!id || !type) throw new Error()\n  } catch (err) {\n    throw new Error('msgr: malformed message')\n  }\n\n  var responder = function (data) {\n    this.send(msgr.types.RESPONSE, data, id)\n  }.bind(this)\n\n  if (this.isWorker && request.data === msgr.types.CONNECT) {\n    // Special init message type that gives us the port\n    // that we will be sending messages to the client over\n    this.recipient = event.ports[0]\n    this.open.resolve()\n  }\n\n  if (request.type === msgr.types.UNKNOWN && request.data in this.handlers) {\n    // Known message type without data, invoke registered handler\n    this.handlers[request.data](null, responder)\n  } else if (request.type in this.handlers) {\n    // Known message type with data, invoke registered handler\n    this.handlers[request.type](request.data, responder)\n  } else if (id && id in this.promises) {\n    // Response to a message, invoke registered response handler\n    var promise = this.promises[id]\n    promise.resolve(request.data)\n    this.promises[id] = null\n  } else {\n    // Unknown message type, invoke receive handlers\n    this.receiveHandlers.forEach(function (handler) {\n      handler(request.data, responder)\n    })\n  }\n}\n\nChannel.prototype.ready = function (fn) {\n  this.open.promise.then(fn)\n}\n\n/**\n * Receive an \"unknown\" message that does not have a predefined handler.\n * @param {Function} handler\n */\nChannel.prototype.receive = function (handler) {\n  if (typeof handler !== 'function') {\n    throw new Error('msgr: expecting handler to be a function')\n  }\n  this.receiveHandlers.push(handler)\n}\n\n/**\n * Send a message.\n * @param {String|*} type The message type or message data\n * @param {*} [data] The message data\n * @returns {Object}\n */\nChannel.prototype.send = function (type, data, _id) {\n  var id = _id || shortid.generate()\n\n  if (!data) {\n    data = type\n    if (type !== msgr.types.RESPONSE) {\n      type = msgr.types.UNKNOWN\n    }\n  }\n\n  var deferred = defer()\n\n  var payload = JSON.stringify({\n    __msgr: true,\n    id: id,\n    type: type,\n    data: data\n  })\n\n  var args = [payload]\n\n  if (this.isClient && data === msgr.types.CONNECT) {\n    args.push([this.messageChannel.port2])\n  }\n\n  this.open.promise.then(function () {\n    this.recipient.postMessage.apply(this.recipient, args)\n  }.bind(this))\n\n  this.promises[id] = deferred\n\n  return deferred.promise\n}\n\n// ---\n// Export\n// ---\n\nvar api = {\n  client: msgr.client,\n  worker: msgr.worker,\n  types: msgr.types\n}\n\nif (typeof define === 'function' && define.amd) {\n  define('msgr', function () { return api })\n} else if (typeof module === 'object' && module.exports) {\n  module.exports = api\n} else {\n  self.msgr = api\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/msgr/index.js\n ** module id = 2\n ** module chunks = 0 1\n **/","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.serialiseRequest=t():e.serialiseRequest=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,t),o.loaded=!0,o.exports}var n={};return t.m=e,t.c=n,t.p=\"\",t(0)}([function(e,t,n){function r(e){return s.blobToArrayBuffer(e).then(function(e){return String.fromCharCode.apply(null,new Uint16Array(e))})}function o(e,t){return s.base64StringToBlob(e).then(function(e){switch(t){case c.ARRAY_BUFFER:return s.blobToArrayBuffer(e);case c.BLOB:return e;case c.FORM_DATA:throw new Error(\"Cannot make FormData from serialised Request\");case c.JSON:return r(e).then(function(e){return JSON.parse(e)});case c.TEXT:return r(e);default:throw new Error('Unknown requested body type \"'+t+'\"')}})}function i(e,t){if(!(e instanceof Request))throw new Error(\"Expecting request to be instance of Request\");for(var n=[],r=e.headers.keys(),o=0;o<r.length;o++){var i=r[o];n[i]=e.headers.get(i)}var u={method:e.method,url:e.url,headers:n,context:e.context,referrer:e.referrer,mode:e.mode,credentials:e.credentials,redirect:e.redirect,integrity:e.integrity,cache:e.cache,bodyUsed:e.bodyUsed};return e.blob().then(s.blobToBase64String).then(function(e){return u.__body=e,t?u:JSON.stringify(u)})}function u(e){var t,n;if(\"string\"==typeof e)t=JSON.parse(e),n=t.url;else{if(\"object\"!=typeof e)throw new Error(\"Expecting serialised request to be a string or object\");t=e,n=t.url}const r=new Request(n,t),i={context:{enumerable:!0,value:t.context}},u=Object.keys(c).reduce(function(e,n){const i=f[n];return e[i]={enumerable:!0,value:function(){return r.bodyUsed?Promise.reject(new TypeError(\"Already used\")):(r.bodyUsed=!0,Promise.resolve(o(t.__body,n)))}},e},i);return Object.defineProperties(r,u),r}var a,a,s=n(1),c={ARRAY_BUFFER:\"ARRAY_BUFFER\",BLOB:\"BLOB\",FORM_DATA:\"FORM_DATA\",JSON:\"JSON\",TEXT:\"TEXT\"},f={ARRAY_BUFFER:\"arrayBuffer\",BLOB:\"blob\",FORM_DATA:\"formData\",JSON:\"json\",TEXT:\"text\"};i.deserialise=u,i.deserialize=u,a=function(){return i}.call(t,n,t,e),!(void 0!==a&&(e.exports=a)),a=function(){return i}.call(t,n,t,e),!(void 0!==a&&(e.exports=a))},function(e,t,n){\"use strict\";function r(e){for(var t=e.length,n=new ArrayBuffer(t),r=new Uint8Array(n),o=-1;++o<t;)r[o]=e.charCodeAt(o);return n}function o(e){for(var t=\"\",n=new Uint8Array(e),r=n.byteLength,o=-1;++o<r;)t+=String.fromCharCode(n[o]);return t}function i(e,t){return new R(function(n,r){var o=new Image;t&&(o.crossOrigin=t),o.onload=function(){n(o)},o.onerror=r,o.src=e})}function u(e){var t=document.createElement(\"canvas\");t.width=e.width,t.height=e.height;var n=t.getContext(\"2d\");return n.drawImage(e,0,0,e.width,e.height,0,0,e.width,e.height),t}function a(e,t){return t=t||{},\"string\"==typeof t&&(t={type:t}),new g(e,t)}function s(e){return(window.URL||window.webkitURL).createObjectURL(e)}function c(e){return(window.URL||window.webkitURL).revokeObjectURL(e)}function f(e){return new R(function(t,n){var r=new FileReader,i=\"function\"==typeof r.readAsBinaryString;r.onloadend=function(e){var n=e.target.result||\"\";return i?t(n):void t(o(n))},r.onerror=n,i?r.readAsBinaryString(e):r.readAsArrayBuffer(e)})}function l(e,t){return R.resolve().then(function(){var n=[r(atob(e))];return t?a(n,{type:t}):a(n)})}function d(e,t){return R.resolve().then(function(){return l(btoa(e),t)})}function h(e){return f(e).then(function(e){return btoa(e)})}function p(e){return R.resolve().then(function(){var t=e.match(/data:([^;]+)/)[1],n=e.replace(/^[^,]+,/,\"\"),o=r(atob(n));return a([o],{type:t})})}function v(e,t,n,r){return t=t||\"image/png\",i(e,n).then(function(e){return u(e)}).then(function(e){return e.toDataURL(t,r)})}function y(e,t,n){return R.resolve().then(function(){return\"function\"==typeof e.toBlob?new R(function(r){e.toBlob(r,t,n)}):p(e.toDataURL(t,n))})}function b(e,t,n,r){return t=t||\"image/png\",i(e,n).then(function(e){return u(e)}).then(function(e){return y(e,t,r)})}function w(e,t){return R.resolve().then(function(){return a([e],t)})}function m(e){return new R(function(t,n){var r=new FileReader;r.onloadend=function(e){var n=e.target.result||new ArrayBuffer(0);t(n)},r.onerror=n,r.readAsArrayBuffer(e)})}var g=n(2),R=n(3);e.exports={createBlob:a,createObjectURL:s,revokeObjectURL:c,imgSrcToBlob:b,imgSrcToDataURL:v,canvasToBlob:y,dataURLToBlob:p,blobToBase64String:h,base64StringToBlob:l,binaryStringToBlob:d,blobToBinaryString:f,arrayBufferToBlob:w,blobToArrayBuffer:m}},function(e,t){(function(t){function n(e){for(var t=0;t<e.length;t++){var n=e[t];if(n.buffer instanceof ArrayBuffer){var r=n.buffer;if(n.byteLength!==r.byteLength){var o=new Uint8Array(n.byteLength);o.set(new Uint8Array(r,n.byteOffset,n.byteLength)),r=o.buffer}e[t]=r}}}function r(e,t){t=t||{};var r=new i;n(e);for(var o=0;o<e.length;o++)r.append(e[o]);return t.type?r.getBlob(t.type):r.getBlob()}function o(e,t){return n(e),new Blob(e,t||{})}var i=t.BlobBuilder||t.WebKitBlobBuilder||t.MSBlobBuilder||t.MozBlobBuilder,u=function(){try{var e=new Blob([\"hi\"]);return 2===e.size}catch(t){return!1}}(),a=u&&function(){try{var e=new Blob([new Uint8Array([1,2])]);return 2===e.size}catch(t){return!1}}(),s=i&&i.prototype.append&&i.prototype.getBlob;e.exports=function(){return u?a?t.Blob:o:s?r:void 0}()}).call(t,function(){return this}())},function(e,t,n){(function(t){\"function\"==typeof t.Promise?e.exports=t.Promise:e.exports=n(4)}).call(t,function(){return this}())},function(e,t,n){var r,r;!function(t){e.exports=t()}(function(){return function e(t,n,o){function i(a,s){if(!n[a]){if(!t[a]){var c=\"function\"==typeof r&&r;if(!s&&c)return r(a,!0);if(u)return u(a,!0);throw new Error(\"Cannot find module '\"+a+\"'\")}var f=n[a]={exports:{}};t[a][0].call(f.exports,function(e){var n=t[a][1][e];return i(n?n:e)},f,f.exports,e,t,n,o)}return n[a].exports}for(var u=\"function\"==typeof r&&r,a=0;a<o.length;a++)i(o[a]);return i}({1:[function(e,t,n){\"use strict\";function r(){}t.exports=r},{}],2:[function(e,t,n){\"use strict\";var r=e(\"./promise\"),o=e(\"./reject\"),i=e(\"./resolve\"),u=e(\"./INTERNAL\"),a=e(\"./handlers\"),s=o(new TypeError(\"must be an array\"));t.exports=function(e){function t(e,t){function r(e){c[t]=e,++f===n&!o&&(o=!0,a.resolve(d,c))}i(e).then(r,function(e){o||(o=!0,a.reject(d,e))})}if(\"[object Array]\"!==Object.prototype.toString.call(e))return s;var n=e.length,o=!1;if(!n)return i([]);for(var c=new Array(n),f=0,l=-1,d=new r(u);++l<n;)t(e[l],l);return d}},{\"./INTERNAL\":1,\"./handlers\":3,\"./promise\":5,\"./reject\":7,\"./resolve\":8}],3:[function(e,t,n){\"use strict\";function r(e){var t=e&&e.then;return e&&\"object\"==typeof e&&\"function\"==typeof t?function(){t.apply(e,arguments)}:void 0}var o=e(\"./tryCatch\"),i=e(\"./resolveThenable\"),u=e(\"./states\");n.resolve=function(e,t){var a=o(r,t);if(\"error\"===a.status)return n.reject(e,a.value);var s=a.value;if(s)i.safely(e,s);else{e.state=u.FULFILLED,e.outcome=t;for(var c=-1,f=e.queue.length;++c<f;)e.queue[c].callFulfilled(t)}return e},n.reject=function(e,t){e.state=u.REJECTED,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e}},{\"./resolveThenable\":9,\"./states\":10,\"./tryCatch\":11}],4:[function(e,t,n){t.exports=n=e(\"./promise\"),n.resolve=e(\"./resolve\"),n.reject=e(\"./reject\"),n.all=e(\"./all\")},{\"./all\":2,\"./promise\":5,\"./reject\":7,\"./resolve\":8}],5:[function(e,t,n){\"use strict\";function r(e){if(!(this instanceof r))return new r(e);if(\"function\"!=typeof e)throw new TypeError(\"reslover must be a function\");this.state=a.PENDING,this.queue=[],this.outcome=void 0,e!==i&&u.safely(this,e)}var o=e(\"./unwrap\"),i=e(\"./INTERNAL\"),u=e(\"./resolveThenable\"),a=e(\"./states\"),s=e(\"./queueItem\");t.exports=r,r.prototype[\"catch\"]=function(e){return this.then(null,e)},r.prototype.then=function(e,t){if(\"function\"!=typeof e&&this.state===a.FULFILLED||\"function\"!=typeof t&&this.state===a.REJECTED)return this;var n=new r(i);if(this.state!==a.PENDING){var u=this.state===a.FULFILLED?e:t;o(n,u,this.outcome)}else this.queue.push(new s(n,e,t));return n}},{\"./INTERNAL\":1,\"./queueItem\":6,\"./resolveThenable\":9,\"./states\":10,\"./unwrap\":12}],6:[function(e,t,n){\"use strict\";function r(e,t,n){this.promise=e,\"function\"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),\"function\"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}var o=e(\"./handlers\"),i=e(\"./unwrap\");t.exports=r,r.prototype.callFulfilled=function(e){o.resolve(this.promise,e)},r.prototype.otherCallFulfilled=function(e){i(this.promise,this.onFulfilled,e)},r.prototype.callRejected=function(e){o.reject(this.promise,e)},r.prototype.otherCallRejected=function(e){i(this.promise,this.onRejected,e)}},{\"./handlers\":3,\"./unwrap\":12}],7:[function(e,t,n){\"use strict\";function r(e){var t=new o(i);return u.reject(t,e)}var o=e(\"./promise\"),i=e(\"./INTERNAL\"),u=e(\"./handlers\");t.exports=r},{\"./INTERNAL\":1,\"./handlers\":3,\"./promise\":5}],8:[function(e,t,n){\"use strict\";function r(e){if(e)return e instanceof o?e:u.resolve(new o(i),e);var t=typeof e;switch(t){case\"boolean\":return a;case\"undefined\":return c;case\"object\":return s;case\"number\":return f;case\"string\":return l}}var o=e(\"./promise\"),i=e(\"./INTERNAL\"),u=e(\"./handlers\");t.exports=r;var a=u.resolve(new o(i),!1),s=u.resolve(new o(i),null),c=u.resolve(new o(i),void 0),f=u.resolve(new o(i),0),l=u.resolve(new o(i),\"\")},{\"./INTERNAL\":1,\"./handlers\":3,\"./promise\":5}],9:[function(e,t,n){\"use strict\";function r(e,t){function n(t){a||(a=!0,o.reject(e,t))}function r(t){a||(a=!0,o.resolve(e,t))}function u(){t(r,n)}var a=!1,s=i(u);\"error\"===s.status&&n(s.value)}var o=e(\"./handlers\"),i=e(\"./tryCatch\");n.safely=r},{\"./handlers\":3,\"./tryCatch\":11}],10:[function(e,t,n){n.REJECTED=[\"REJECTED\"],n.FULFILLED=[\"FULFILLED\"],n.PENDING=[\"PENDING\"]},{}],11:[function(e,t,n){\"use strict\";function r(e,t){var n={};try{n.value=e(t),n.status=\"success\"}catch(r){n.status=\"error\",n.value=r}return n}t.exports=r},{}],12:[function(e,t,n){\"use strict\";function r(e,t,n){o(function(){var r;try{r=t(n)}catch(o){return i.reject(e,o)}r===e?i.reject(e,new TypeError(\"Cannot resolve promise with itself\")):i.resolve(e,r)})}var o=e(\"immediate\"),i=e(\"./handlers\");t.exports=r},{\"./handlers\":3,immediate:13}],13:[function(e,t,n){\"use strict\";function r(){i=!0;for(var e,t,n=s.length;n;){for(t=s,s=[],e=-1;++e<n;)t[e]();n=s.length}i=!1}function o(e){1!==s.push(e)||i||u()}for(var i,u,a=[e(\"./nextTick\"),e(\"./messageChannel\"),e(\"./stateChange\"),e(\"./timeout\")],s=[],c=-1,f=a.length;++c<f;)if(a[c].test()){u=a[c].install(r);break}t.exports=o},{\"./messageChannel\":14,\"./nextTick\":15,\"./stateChange\":16,\"./timeout\":17}],14:[function(e,t,n){(function(e){\"use strict\";n.test=function(){return e.setImmediate?!1:\"undefined\"!=typeof e.MessageChannel},n.install=function(t){var n=new e.MessageChannel;return n.port1.onmessage=t,function(){n.port2.postMessage(0)}}}).call(this,\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],15:[function(e,t,n){(function(e){\"use strict\";var t=e.MutationObserver||e.WebKitMutationObserver;n.test=function(){return t},n.install=function(n){var r=0,o=new t(n),i=e.document.createTextNode(\"\");return o.observe(i,{characterData:!0}),function(){i.data=r=++r%2}}}).call(this,\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],16:[function(e,t,n){(function(e){\"use strict\";n.test=function(){return\"document\"in e&&\"onreadystatechange\"in e.document.createElement(\"script\")},n.install=function(t){return function(){var n=e.document.createElement(\"script\");return n.onreadystatechange=function(){t(),n.onreadystatechange=null,n.parentNode.removeChild(n),n=null},e.document.documentElement.appendChild(n),t}}}).call(this,\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],17:[function(e,t,n){\"use strict\";n.test=function(){return!0},n.install=function(e){return function(){setTimeout(e,0)}}},{}]},{},[4])(4)})}])});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/serialise-request/dist/serialise-request.min.js\n ** module id = 3\n ** module chunks = 0 1\n **/","'use strict'\n\n/* global Response:false, FileReader:false */\n\n// https://gist.github.com/davoclavo/4424731\nfunction dataURItoBlob (dataURI) {\n  var byteString = atob(dataURI.split(',')[1])\n  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]\n  var arrayBuffer = new ArrayBuffer(byteString.length)\n  var _ia = new Uint8Array(arrayBuffer)\n  for (var i = 0; i < byteString.length; i++) {\n    _ia[i] = byteString.charCodeAt(i)\n  }\n  var dataView = new DataView(arrayBuffer)\n  return new Blob([dataView.buffer], {type: mimeString})\n}\n\n/**\n * Serialise a Response to a string or object.\n * @param {Response} response\n */\nfunction serialiseResponse (response) {\n  if (!(response instanceof Response)) {\n    throw new Error('Expecting response to be instance of Response')\n  }\n\n  var headers = []\n  var headerNames = response.headers.keys()\n  for (var i = 0; i < headerNames.length; i++) {\n    var headerName = headerNames[i]\n    headers[headerName] = response.headers.get(headerName)\n  }\n\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader()\n    response.blob().then(function (blob) {\n      return reader.readAsDataURL(blob)\n    })\n    reader.onerror = reject\n    reader.onloadend = function () {\n      resolve(JSON.stringify({\n        type: response.type,\n        url: response.url,\n        useFinalURL: response.useFinalURL,\n        status: response.status,\n        ok: response.ok,\n        statusText: response.statusText,\n        headers: headers,\n        __body: reader.result\n      }))\n    }\n  })\n}\n\n/**\n * De-serialise a Response from a string or object.\n * @param {Object|String} response\n */\nfunction deserialiseResponse (response) {\n  var realResponse\n\n  if (typeof response === 'string') {\n    realResponse = JSON.parse(response)\n  } else if (typeof response === 'object') {\n    realResponse = response\n  } else {\n    throw new Error('Expecting serialised response to be a string or object')\n  }\n\n  return new Response(dataURItoBlob(realResponse.__body))\n}\n\nserialiseResponse.deserialise = deserialiseResponse\nserialiseResponse.deserialize = deserialiseResponse\n\n/* global define:false window:false */\nif (typeof define === 'function' && define.amd) {\n  define('serialiseResponse', function () {\n    return serialiseResponse\n  })\n  define('serializeResponse', function () {\n    return serialiseResponse\n  })\n} else if (typeof module === 'object' && module.exports) {\n  module.exports = serialiseResponse\n} else if (typeof window !== 'undefined') {\n  window.serialiseResponse = serialiseResponse\n  window.serializeResponse = serialiseResponse\n} else {\n  throw new Error(\n    'Environment is not supported. ' +\n    'Please raise an issue at https://github.com/sdgluck/serialise-response/issues'\n  )\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/serialise-response/index.js\n ** module id = 4\n ** module chunks = 0 1\n **/","'use strict'\n\n/* global Promise:false */\n\n/**\n * Create a deferred.\n * @returns {Object}\n */\nfunction defer () {\n  var res\n  var rej\n  var promise = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  })\n  return {\n    promise: promise,\n    resolve: res,\n    reject: rej\n  }\n}\n\n/* global define:false window:false */\nif (typeof define === 'function' && define.amd) {\n  define('miniDefer', function () {\n    return defer\n  })\n} else if (typeof module === 'object' && module.exports) {\n  module.exports = defer\n} else if (typeof window !== 'undefined') {\n  window.miniDefer = defer\n} else {\n  throw new Error(\n    'Environment is not supported. ' +\n    'Please raise an issue at https://github.com/sdgluck/mini-defer/issues'\n  )\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/msgr/~/mini-defer/index.js\n ** module id = 5\n ** module chunks = 0 1\n **/","'use strict';\nvar alphabet = require('./alphabet');\n\n/**\n * Decode the id to get the version and worker\n * Mainly for debugging and testing.\n * @param id - the shortid-generated id.\n */\nfunction decode(id) {\n    var characters = alphabet.shuffled();\n    return {\n        version: characters.indexOf(id.substr(0, 1)) & 0x0f,\n        worker: characters.indexOf(id.substr(1, 1)) & 0x0f\n    };\n}\n\nmodule.exports = decode;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/lib/decode.js\n ** module id = 6\n ** module chunks = 0 1\n **/","'use strict';\n\nvar randomByte = require('./random/random-byte');\n\nfunction encode(lookup, number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = encode;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/lib/encode.js\n ** module id = 7\n ** module chunks = 0 1\n **/","'use strict';\n\nvar alphabet = require('./alphabet');\nvar encode = require('./encode');\nvar decode = require('./decode');\nvar isValid = require('./is-valid');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + encode(alphabet.lookup, version);\n    str = str + encode(alphabet.lookup, clusterWorkerId);\n    if (counter > 0) {\n        str = str + encode(alphabet.lookup, counter);\n    }\n    str = str + encode(alphabet.lookup, seconds);\n\n    return str;\n}\n\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.decode = decode;\nmodule.exports.isValid = isValid;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/lib/index.js\n ** module id = 8\n ** module chunks = 0 1\n **/","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var characters = alphabet.characters();\n    var len = id.length;\n    for(var i = 0; i < len;i++) {\n        if (characters.indexOf(id[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nmodule.exports = isShortId;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/lib/is-valid.js\n ** module id = 9\n ** module chunks = 0 1\n **/","'use strict';\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nfunction randomByte() {\n    if (!crypto || !crypto.getRandomValues) {\n        return Math.floor(Math.random() * 256) & 0x30;\n    }\n    var dest = new Uint8Array(1);\n    crypto.getRandomValues(dest);\n    return dest[0] & 0x30;\n}\n\nmodule.exports = randomByte;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/lib/random/random-byte-browser.js\n ** module id = 10\n ** module chunks = 0 1\n **/","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/lib/random/random-from-seed.js\n ** module id = 11\n ** module chunks = 0 1\n **/","'use strict';\n\nmodule.exports = 0;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/shortid/lib/util/cluster-worker-id-browser.js\n ** module id = 12\n ** module chunks = 0 1\n **/","/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.7.0\n * Copyright (c) 2011 - 2016 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT (X11) license\n */\n\n(function (name, definition, global) {\n\n    'use strict';\n\n    if (typeof define === 'function') {\n        define(definition);\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = definition();\n    } else {\n        global[name] = definition();\n    }\n})('IDBStore', function () {\n\n    'use strict';\n\n    var defaultErrorHandler = function (error) {\n        throw error;\n    };\n    var defaultSuccessHandler = function () {\n    };\n\n    var defaults = {\n        storeName: 'Store',\n        storePrefix: 'IDBWrapper-',\n        dbVersion: 1,\n        keyPath: 'id',\n        autoIncrement: true,\n        onStoreReady: function () {\n        },\n        onError: defaultErrorHandler,\n        indexes: [],\n        implementationPreference: [\n            'indexedDB',\n            'webkitIndexedDB',\n            'mozIndexedDB',\n            'shimIndexedDB'\n        ]\n    };\n\n    /**\n     *\n     * The IDBStore constructor\n     *\n     * @constructor\n     * @name IDBStore\n     * @version 1.7.0\n     *\n     * @param {Object} [kwArgs] An options object used to configure the store and\n     *  set callbacks\n     * @param {String} [kwArgs.storeName='Store'] The name of the store\n     * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n     *  internally used to construct the name of the database, which will be\n     *  kwArgs.storePrefix + kwArgs.storeName\n     * @param {Number} [kwArgs.dbVersion=1] The version of the store\n     * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n     *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n     *  `null`\n     * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n     *  automatically make sure a unique keyPath value is present on each object\n     *  that is stored.\n     * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n     *  store is ready to be used.\n     * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n     *  error occurred during instantiation of the store.\n     * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n     *  defining the indexes to use with the store. For every index to be used\n     *  one indexData object needs to be passed in the array.\n     *  An indexData object is defined as follows:\n     * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n     *  use\n     * @param {String} kwArgs.indexes.indexData.name The name of the index\n     * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n     * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n     * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n     * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n     * @param {Function} [onStoreReady] A callback to be called when the store\n     * is ready to be used.\n     * @example\n     // create a store for customers with an additional index over the\n     // `lastname` property.\n     var myCustomerStore = new IDBStore({\n         dbVersion: 1,\n         storeName: 'customer-index',\n         keyPath: 'customerid',\n         autoIncrement: true,\n         onStoreReady: populateTable,\n         indexes: [\n             { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n         ]\n     });\n     * @example\n     // create a generic store\n     var myCustomerStore = new IDBStore({\n         storeName: 'my-data-store',\n         onStoreReady: function(){\n             // start working with the store.\n         }\n     });\n     */\n    var IDBStore = function (kwArgs, onStoreReady) {\n\n        if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n            onStoreReady = kwArgs;\n        }\n        if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n            kwArgs = {};\n        }\n\n        for (var key in defaults) {\n            this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n        }\n\n        this.dbName = this.storePrefix + this.storeName;\n        this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n        onStoreReady && (this.onStoreReady = onStoreReady);\n\n        var env = typeof window == 'object' ? window : self;\n        var availableImplementations = this.implementationPreference.filter(function (implName) {\n            return implName in env;\n        });\n        this.implementation = availableImplementations[0];\n        this.idb = env[this.implementation];\n        this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n        this.consts = {\n            'READ_ONLY': 'readonly',\n            'READ_WRITE': 'readwrite',\n            'VERSION_CHANGE': 'versionchange',\n            'NEXT': 'next',\n            'NEXT_NO_DUPLICATE': 'nextunique',\n            'PREV': 'prev',\n            'PREV_NO_DUPLICATE': 'prevunique'\n        };\n\n        this.openDB();\n    };\n\n    /** @lends IDBStore.prototype */\n    var proto = {\n\n        /**\n         * A pointer to the IDBStore ctor\n         *\n         * @private\n         * @type {Function}\n         * @constructs\n         */\n        constructor: IDBStore,\n\n        /**\n         * The version of IDBStore\n         *\n         * @type {String}\n         */\n        version: '1.7.0',\n\n        /**\n         * A reference to the IndexedDB object\n         *\n         * @type {IDBDatabase}\n         */\n        db: null,\n\n        /**\n         * The full name of the IndexedDB used by IDBStore, composed of\n         * this.storePrefix + this.storeName\n         *\n         * @type {String}\n         */\n        dbName: null,\n\n        /**\n         * The version of the IndexedDB used by IDBStore\n         *\n         * @type {Number}\n         */\n        dbVersion: null,\n\n        /**\n         * A reference to the objectStore used by IDBStore\n         *\n         * @type {IDBObjectStore}\n         */\n        store: null,\n\n        /**\n         * The store name\n         *\n         * @type {String}\n         */\n        storeName: null,\n\n        /**\n         * The prefix to prepend to the store name\n         *\n         * @type {String}\n         */\n        storePrefix: null,\n\n        /**\n         * The key path\n         *\n         * @type {String}\n         */\n        keyPath: null,\n\n        /**\n         * Whether IDBStore uses autoIncrement\n         *\n         * @type {Boolean}\n         */\n        autoIncrement: null,\n\n        /**\n         * The indexes used by IDBStore\n         *\n         * @type {Array}\n         */\n        indexes: null,\n\n        /**\n         * The implemantations to try to use, in order of preference\n         *\n         * @type {Array}\n         */\n        implementationPreference: null,\n\n        /**\n         * The actual implementation being used\n         *\n         * @type {String}\n         */\n        implementation: '',\n\n        /**\n         * The callback to be called when the store is ready to be used\n         *\n         * @type {Function}\n         */\n        onStoreReady: null,\n\n        /**\n         * The callback to be called if an error occurred during instantiation\n         * of the store\n         *\n         * @type {Function}\n         */\n        onError: null,\n\n        /**\n         * The internal insertID counter\n         *\n         * @type {Number}\n         * @private\n         */\n        _insertIdCount: 0,\n\n        /**\n         * Opens an IndexedDB; called by the constructor.\n         *\n         * Will check if versions match and compare provided index configuration\n         * with existing ones, and update indexes if necessary.\n         *\n         * Will call this.onStoreReady() if everything went well and the store\n         * is ready to use, and this.onError() is something went wrong.\n         *\n         * @private\n         *\n         */\n        openDB: function () {\n\n            var openRequest = this.idb.open(this.dbName, this.dbVersion);\n            var preventSuccessCallback = false;\n\n            openRequest.onerror = function (error) {\n\n                var gotVersionErr = false;\n                if ('error' in error.target) {\n                    gotVersionErr = error.target.error.name == 'VersionError';\n                } else if ('errorCode' in error.target) {\n                    gotVersionErr = error.target.errorCode == 12;\n                }\n\n                if (gotVersionErr) {\n                    this.onError(new Error('The version number provided is lower than the existing one.'));\n                } else {\n                    this.onError(error);\n                }\n            }.bind(this);\n\n            openRequest.onsuccess = function (event) {\n\n                if (preventSuccessCallback) {\n                    return;\n                }\n\n                if (this.db) {\n                    this.onStoreReady();\n                    return;\n                }\n\n                this.db = event.target.result;\n\n                if (typeof this.db.version == 'string') {\n                    this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n                    return;\n                }\n\n                if (!this.db.objectStoreNames.contains(this.storeName)) {\n                    // We should never ever get here.\n                    // Lets notify the user anyway.\n                    this.onError(new Error('Object store couldn\\'t be created.'));\n                    return;\n                }\n\n                var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n                this.store = emptyTransaction.objectStore(this.storeName);\n\n                // check indexes\n                var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n                this.indexes.forEach(function (indexData) {\n                    var indexName = indexData.name;\n\n                    if (!indexName) {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create index: No index name given.'));\n                        return;\n                    }\n\n                    this.normalizeIndexData(indexData);\n\n                    if (this.hasIndex(indexName)) {\n                        // check if it complies\n                        var actualIndex = this.store.index(indexName);\n                        var complies = this.indexComplies(actualIndex, indexData);\n                        if (!complies) {\n                            preventSuccessCallback = true;\n                            this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                        }\n\n                        existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n                    } else {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                    }\n\n                }, this);\n\n                if (existingIndexes.length) {\n                    preventSuccessCallback = true;\n                    this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                }\n\n                preventSuccessCallback || this.onStoreReady();\n            }.bind(this);\n\n            openRequest.onupgradeneeded = function (/* IDBVersionChangeEvent */ event) {\n\n                this.db = event.target.result;\n\n                if (this.db.objectStoreNames.contains(this.storeName)) {\n                    this.store = event.target.transaction.objectStore(this.storeName);\n                } else {\n                    var optionalParameters = {autoIncrement: this.autoIncrement};\n                    if (this.keyPath !== null) {\n                        optionalParameters.keyPath = this.keyPath;\n                    }\n                    this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n                }\n\n                var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n                this.indexes.forEach(function (indexData) {\n                    var indexName = indexData.name;\n\n                    if (!indexName) {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create index: No index name given.'));\n                    }\n\n                    this.normalizeIndexData(indexData);\n\n                    if (this.hasIndex(indexName)) {\n                        // check if it complies\n                        var actualIndex = this.store.index(indexName);\n                        var complies = this.indexComplies(actualIndex, indexData);\n                        if (!complies) {\n                            // index differs, need to delete and re-create\n                            this.store.deleteIndex(indexName);\n                            this.store.createIndex(indexName, indexData.keyPath, {\n                                unique: indexData.unique,\n                                multiEntry: indexData.multiEntry\n                            });\n                        }\n\n                        existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n                    } else {\n                        this.store.createIndex(indexName, indexData.keyPath, {\n                            unique: indexData.unique,\n                            multiEntry: indexData.multiEntry\n                        });\n                    }\n\n                }, this);\n\n                if (existingIndexes.length) {\n                    existingIndexes.forEach(function (_indexName) {\n                        this.store.deleteIndex(_indexName);\n                    }, this);\n                }\n\n            }.bind(this);\n        },\n\n        /**\n         * Deletes the database used for this store if the IDB implementations\n         * provides that functionality.\n         *\n         * @param {Function} [onSuccess] A callback that is called if deletion\n         *  was successful.\n         * @param {Function} [onError] A callback that is called if deletion\n         *  failed.\n         */\n        deleteDatabase: function (onSuccess, onError) {\n            if (this.idb.deleteDatabase) {\n                this.db.close();\n                var deleteRequest = this.idb.deleteDatabase(this.dbName);\n                deleteRequest.onsuccess = onSuccess;\n                deleteRequest.onerror = onError;\n            } else {\n                onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n            }\n        },\n\n        /*********************\n         * data manipulation *\n         *********************/\n\n        /**\n         * Puts an object into the store. If an entry with the given id exists,\n         * it will be overwritten. This method has a different signature for inline\n         * keys and out-of-line keys; please see the examples below.\n         *\n         * @param {*} [key] The key to store. This is only needed if IDBWrapper\n         *  is set to use out-of-line keys. For inline keys - the default scenario -\n         *  this can be omitted.\n         * @param {Object} value The data object to store.\n         * @param {Function} [onSuccess] A callback that is called if insertion\n         *  was successful.\n         * @param {Function} [onError] A callback that is called if insertion\n         *  failed.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         * @example\n         // Storing an object, using inline keys (the default scenario):\n         var myCustomer = {\n             customerid: 2346223,\n             lastname: 'Doe',\n             firstname: 'John'\n         };\n         myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n         // Note that passing success- and error-handlers is optional.\n         * @example\n         // Storing an object, using out-of-line keys:\n         var myCustomer = {\n             lastname: 'Doe',\n             firstname: 'John'\n         };\n         myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n         // Note that passing success- and error-handlers is optional.\n         */\n        put: function (key, value, onSuccess, onError) {\n            if (this.keyPath !== null) {\n                onError = onSuccess;\n                onSuccess = value;\n                value = key;\n            }\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null,\n                putRequest;\n\n            var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            putTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            putTransaction.onabort = onError;\n            putTransaction.onerror = onError;\n\n            if (this.keyPath !== null) { // in-line keys\n                this._addIdPropertyIfNeeded(value);\n                putRequest = putTransaction.objectStore(this.storeName).put(value);\n            } else { // out-of-line keys\n                putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n            }\n            putRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            putRequest.onerror = onError;\n\n            return putTransaction;\n        },\n\n        /**\n         * Retrieves an object from the store. If no entry exists with the given id,\n         * the success handler will be called with null as first and only argument.\n         *\n         * @param {*} key The id of the object to fetch.\n         * @param {Function} [onSuccess] A callback that is called if fetching\n         *  was successful. Will receive the object as only argument.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        get: function (key, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            getTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getTransaction.onabort = onError;\n            getTransaction.onerror = onError;\n            var getRequest = getTransaction.objectStore(this.storeName).get(key);\n            getRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            getRequest.onerror = onError;\n\n            return getTransaction;\n        },\n\n        /**\n         * Removes an object from the store.\n         *\n         * @param {*} key The id of the object to remove.\n         * @param {Function} [onSuccess] A callback that is called if the removal\n         *  was successful.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        remove: function (key, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            removeTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            removeTransaction.onabort = onError;\n            removeTransaction.onerror = onError;\n\n            var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n            deleteRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            deleteRequest.onerror = onError;\n\n            return removeTransaction;\n        },\n\n        /**\n         * Runs a batch of put and/or remove operations on the store.\n         *\n         * @param {Array} dataArray An array of objects containing the operation to run\n         *  and the data object (for put operations).\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        batch: function (dataArray, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n                onError(new Error('dataArray argument must be of type Array.'));\n            } else if (dataArray.length === 0) {\n                return onSuccess(true);\n            }\n\n            var count = dataArray.length;\n            var called = false;\n            var hasSuccess = false;\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            batchTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(hasSuccess);\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n\n            var onItemSuccess = function () {\n                count--;\n                if (count === 0 && !called) {\n                    called = true;\n                    hasSuccess = true;\n                }\n            };\n\n            dataArray.forEach(function (operation) {\n                var type = operation.type;\n                var key = operation.key;\n                var value = operation.value;\n\n                var onItemError = function (err) {\n                    batchTransaction.abort();\n                    if (!called) {\n                        called = true;\n                        onError(err, type, key);\n                    }\n                };\n\n                if (type == 'remove') {\n                    var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n                    deleteRequest.onsuccess = onItemSuccess;\n                    deleteRequest.onerror = onItemError;\n                } else if (type == 'put') {\n                    var putRequest;\n                    if (this.keyPath !== null) { // in-line keys\n                        this._addIdPropertyIfNeeded(value);\n                        putRequest = batchTransaction.objectStore(this.storeName).put(value);\n                    } else { // out-of-line keys\n                        putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n                    }\n                    putRequest.onsuccess = onItemSuccess;\n                    putRequest.onerror = onItemError;\n                }\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Takes an array of objects and stores them in a single transaction.\n         *\n         * @param {Array} dataArray An array of objects to store\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        putBatch: function (dataArray, onSuccess, onError) {\n            var batchData = dataArray.map(function (item) {\n                return {type: 'put', value: item};\n            });\n\n            return this.batch(batchData, onSuccess, onError);\n        },\n\n        /**\n         * Like putBatch, takes an array of objects and stores them in a single\n         * transaction, but allows processing of the result values.  Returns the\n         * processed records containing the key for newly created records to the\n         * onSuccess calllback instead of only returning true or false for success.\n         * In addition, added the option for the caller to specify a key field that\n         * should be set to the newly created key.\n         *\n         * @param {Array} dataArray An array of objects to store\n         * @param {Object} [options] An object containing optional options\n         * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n         *  with the auto-incrementing key. Defaults to the store's keyPath.\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         *\n         */\n        upsertBatch: function (dataArray, options, onSuccess, onError) {\n            // handle `dataArray, onSuccess, onError` signature\n            if (typeof options == 'function') {\n                onSuccess = options;\n                onError = onSuccess;\n                options = {};\n            }\n\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            options || (options = {});\n\n            if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n                onError(new Error('dataArray argument must be of type Array.'));\n            }\n\n            var keyField = options.keyField || this.keyPath;\n            var count = dataArray.length;\n            var called = false;\n            var hasSuccess = false;\n            var index = 0; // assume success callbacks are executed in order\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            batchTransaction.oncomplete = function () {\n                if (hasSuccess) {\n                    onSuccess(dataArray);\n                } else {\n                    onError(false);\n                }\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n            var onItemSuccess = function (event) {\n                var record = dataArray[index++];\n                record[keyField] = event.target.result;\n\n                count--;\n                if (count === 0 && !called) {\n                    called = true;\n                    hasSuccess = true;\n                }\n            };\n\n            dataArray.forEach(function (record) {\n                var key = record.key;\n\n                var onItemError = function (err) {\n                    batchTransaction.abort();\n                    if (!called) {\n                        called = true;\n                        onError(err);\n                    }\n                };\n\n                var putRequest;\n                if (this.keyPath !== null) { // in-line keys\n                    this._addIdPropertyIfNeeded(record);\n                    putRequest = batchTransaction.objectStore(this.storeName).put(record);\n                } else { // out-of-line keys\n                    putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n                }\n                putRequest.onsuccess = onItemSuccess;\n                putRequest.onerror = onItemError;\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Takes an array of keys and removes matching objects in a single\n         * transaction.\n         *\n         * @param {Array} keyArray An array of keys to remove\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        removeBatch: function (keyArray, onSuccess, onError) {\n            var batchData = keyArray.map(function (key) {\n                return {type: 'remove', key: key};\n            });\n\n            return this.batch(batchData, onSuccess, onError);\n        },\n\n        /**\n         * Takes an array of keys and fetches matching objects\n         *\n         * @param {Array} keyArray An array of keys identifying the objects to fetch\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @param {String} [arrayType='sparse'] The type of array to pass to the\n         *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n         *  'sparse'. This parameter specifies how to handle the situation if a get\n         *  operation did not throw an error, but there was no matching object in\n         *  the database. In most cases, 'sparse' provides the most desired\n         *  behavior. See the examples for details.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         * @example\n         // given that there are two objects in the database with the keypath\n         // values 1 and 2, and the call looks like this:\n         myStore.getBatch([1, 5, 2], onError, function (data) { … }, arrayType);\n\n         // this is what the `data` array will be like:\n\n         // arrayType == 'sparse':\n         // data is a sparse array containing two entries and having a length of 3:\n         [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         // calling forEach on data will result in the callback being called two\n         // times, with the index parameter matching the index of the key in the\n         // keyArray.\n\n         // arrayType == 'dense':\n         // data is a dense array containing three entries and having a length of 3,\n         // where data[1] is of type undefined:\n         [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         // calling forEach on data will result in the callback being called three\n         // times, with the index parameter matching the index of the key in the\n         // keyArray, but the second call will have undefined as first argument.\n\n         // arrayType == 'skip':\n         // data is a dense array containing two entries and having a length of 2:\n         [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         // calling forEach on data will result in the callback being called two\n         // times, with the index parameter not matching the index of the key in the\n         // keyArray.\n         */\n        getBatch: function (keyArray, onSuccess, onError, arrayType) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            arrayType || (arrayType = 'sparse');\n\n            if (Object.prototype.toString.call(keyArray) != '[object Array]') {\n                onError(new Error('keyArray argument must be of type Array.'));\n            } else if (keyArray.length === 0) {\n                return onSuccess([]);\n            }\n\n            var data = [];\n            var count = keyArray.length;\n            var called = false;\n            var hasSuccess = false;\n            var result = null;\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            batchTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n            var onItemSuccess = function (event) {\n                if (event.target.result || arrayType == 'dense') {\n                    data.push(event.target.result);\n                } else if (arrayType == 'sparse') {\n                    data.length++;\n                }\n                count--;\n                if (count === 0) {\n                    called = true;\n                    hasSuccess = true;\n                    result = data;\n                }\n            };\n\n            keyArray.forEach(function (key) {\n\n                var onItemError = function (err) {\n                    called = true;\n                    result = err;\n                    onError(err);\n                    batchTransaction.abort();\n                };\n\n                var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n                getRequest.onsuccess = onItemSuccess;\n                getRequest.onerror = onItemError;\n\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Fetches all entries in the store.\n         *\n         * @param {Function} [onSuccess] A callback that is called if the operation\n         *  was successful. Will receive an array of objects.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        getAll: function (onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            var store = getAllTransaction.objectStore(this.storeName);\n            if (store.getAll) {\n                this._getAllNative(getAllTransaction, store, onSuccess, onError);\n            } else {\n                this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n            }\n\n            return getAllTransaction;\n        },\n\n        /**\n         * Implements getAll for IDB implementations that have a non-standard\n         * getAll() method.\n         *\n         * @param {IDBTransaction} getAllTransaction An open READ transaction.\n         * @param {IDBObjectStore} store A reference to the store.\n         * @param {Function} onSuccess A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} onError A callback that will be called if an\n         *  error occurred during the operation.\n         * @private\n         */\n        _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n            var hasSuccess = false,\n                result = null;\n\n            getAllTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getAllTransaction.onabort = onError;\n            getAllTransaction.onerror = onError;\n\n            var getAllRequest = store.getAll();\n            getAllRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            getAllRequest.onerror = onError;\n        },\n\n        /**\n         * Implements getAll for IDB implementations that do not have a getAll()\n         * method.\n         *\n         * @param {IDBTransaction} getAllTransaction An open READ transaction.\n         * @param {IDBObjectStore} store A reference to the store.\n         * @param {Function} onSuccess A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} onError A callback that will be called if an\n         *  error occurred during the operation.\n         * @private\n         */\n        _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n            var all = [],\n                hasSuccess = false,\n                result = null;\n\n            getAllTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getAllTransaction.onabort = onError;\n            getAllTransaction.onerror = onError;\n\n            var cursorRequest = store.openCursor();\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    all.push(cursor.value);\n                    cursor['continue']();\n                }\n                else {\n                    hasSuccess = true;\n                    result = all;\n                }\n            };\n            cursorRequest.onError = onError;\n        },\n\n        /**\n         * Clears the store, i.e. deletes all entries in the store.\n         *\n         * @param {Function} [onSuccess] A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} [onError] A callback that will be called if an\n         *  error occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        clear: function (onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            clearTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            clearTransaction.onabort = onError;\n            clearTransaction.onerror = onError;\n\n            var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n            clearRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            clearRequest.onerror = onError;\n\n            return clearTransaction;\n        },\n\n        /**\n         * Checks if an id property needs to present on a object and adds one if\n         * necessary.\n         *\n         * @param {Object} dataObj The data object that is about to be stored\n         * @private\n         */\n        _addIdPropertyIfNeeded: function (dataObj) {\n            if (typeof dataObj[this.keyPath] == 'undefined') {\n                dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n            }\n        },\n\n        /************\n         * indexing *\n         ************/\n\n        /**\n         * Returns a DOMStringList of index names of the store.\n         *\n         * @return {DOMStringList} The list of index names\n         */\n        getIndexList: function () {\n            return this.store.indexNames;\n        },\n\n        /**\n         * Checks if an index with the given name exists in the store.\n         *\n         * @param {String} indexName The name of the index to look for\n         * @return {Boolean} Whether the store contains an index with the given name\n         */\n        hasIndex: function (indexName) {\n            return this.store.indexNames.contains(indexName);\n        },\n\n        /**\n         * Normalizes an object containing index data and assures that all\n         * properties are set.\n         *\n         * @param {Object} indexData The index data object to normalize\n         * @param {String} indexData.name The name of the index\n         * @param {String} [indexData.keyPath] The key path of the index\n         * @param {Boolean} [indexData.unique] Whether the index is unique\n         * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n         */\n        normalizeIndexData: function (indexData) {\n            indexData.keyPath = indexData.keyPath || indexData.name;\n            indexData.unique = !!indexData.unique;\n            indexData.multiEntry = !!indexData.multiEntry;\n        },\n\n        /**\n         * Checks if an actual index complies with an expected index.\n         *\n         * @param {IDBIndex} actual The actual index found in the store\n         * @param {Object} expected An Object describing an expected index\n         * @return {Boolean} Whether both index definitions are identical\n         */\n        indexComplies: function (actual, expected) {\n            var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n                // IE10 returns undefined for no multiEntry\n                if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n                    return true;\n                }\n                // Compound keys\n                if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n                    var exp = expected.keyPath;\n                    var act = actual.keyPath;\n\n                    // IE10 can't handle keyPath sequences and stores them as a string.\n                    // The index will be unusable there, but let's still return true if\n                    // the keyPath sequence matches.\n                    if (typeof act == 'string') {\n                        return exp.toString() == act;\n                    }\n\n                    // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n                    // as Array\n                    if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {\n                        return false;\n                    }\n\n                    if (act.length !== exp.length) {\n                        return false;\n                    }\n\n                    for (var i = 0, m = exp.length; i < m; i++) {\n                        if (!( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return expected[key] == actual[key];\n            });\n            return complies;\n        },\n\n        /**********\n         * cursor *\n         **********/\n\n        /**\n         * Iterates over the store using the given options and calling onItem\n         * for each entry matching the options.\n         *\n         * @param {Function} onItem A callback to be called for each match\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {String} [options.order=ASC] The order in which to provide the\n         *  results, can be 'DESC' or 'ASC'\n         * @param {Boolean} [options.autoContinue=true] Whether to automatically\n         *  iterate the cursor to the next result\n         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n         *  duplicate matches\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Boolean} [options.writeAccess=false] Whether grant write access\n         *  to the store in the onItem callback\n         * @param {Function} [options.onEnd=null] A callback to be called after\n         *  iteration has ended\n         * @param {Function} [options.onError=throw] A callback to be called\n         *  if an error occurred during the operation.\n         * @param {Number} [options.limit=Infinity] Limit the number of returned\n         *  results to this number\n         * @param {Number} [options.offset=0] Skip the provided number of results\n         *  in the resultset\n         * @param {Boolean} [options.allowItemRejection=false] Allows the onItem\n         * function to return a Boolean to accept or reject the current item\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        iterate: function (onItem, options) {\n            options = mixin({\n                index: null,\n                order: 'ASC',\n                autoContinue: true,\n                filterDuplicates: false,\n                keyRange: null,\n                writeAccess: false,\n                onEnd: null,\n                onError: defaultErrorHandler,\n                limit: Infinity,\n                offset: 0,\n                allowItemRejection: false\n            }, options || {});\n\n            var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n            if (options.filterDuplicates) {\n                directionType += '_NO_DUPLICATE';\n            }\n\n            var hasSuccess = false;\n            var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n            var cursorTarget = cursorTransaction.objectStore(this.storeName);\n            if (options.index) {\n                cursorTarget = cursorTarget.index(options.index);\n            }\n            var recordCount = 0;\n\n            cursorTransaction.oncomplete = function () {\n                if (!hasSuccess) {\n                    options.onError(null);\n                    return;\n                }\n                if (options.onEnd) {\n                    options.onEnd();\n                } else {\n                    onItem(null);\n                }\n            };\n            cursorTransaction.onabort = options.onError;\n            cursorTransaction.onerror = options.onError;\n\n            var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n            cursorRequest.onerror = options.onError;\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    if (options.offset) {\n                        cursor.advance(options.offset);\n                        options.offset = 0;\n                    } else {\n                        var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);\n                        if (!options.allowItemRejection || onItemReturn !== false) {\n                            recordCount++;\n                        }\n                        if (options.autoContinue) {\n                            if (recordCount + options.offset < options.limit) {\n                                cursor['continue']();\n                            } else {\n                                hasSuccess = true;\n                            }\n                        }\n                    }\n                } else {\n                    hasSuccess = true;\n                }\n            };\n\n            return cursorTransaction;\n        },\n\n        /**\n         * Runs a query against the store and passes an array containing matched\n         * objects to the success handler.\n         *\n         * @param {Function} onSuccess A callback to be called when the operation\n         *  was successful.\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {String} [options.order=ASC] The order in which to provide the\n         *  results, can be 'DESC' or 'ASC'\n         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n         *  duplicate matches\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Function} [options.onError=throw] A callback to be called\n         *  if an error occurred during the operation.\n         * @param {Number} [options.limit=Infinity] Limit the number of returned\n         *  results to this number\n         * @param {Number} [options.offset=0] Skip the provided number of results\n         *  in the resultset\n         * @param {Function} [options.filter=null] A custom filter function to\n         *  apply to query resuts before returning. Must return `false` to reject\n         *  an item. Can be combined with keyRanges.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        query: function (onSuccess, options) {\n            var result = [],\n                processedItems = 0;\n            options = options || {};\n            options.autoContinue = true;\n            options.writeAccess = false;\n            options.allowItemRejection = !!options.filter;\n            options.onEnd = function () {\n                onSuccess(result, processedItems);\n            };\n            return this.iterate(function (item) {\n                processedItems++;\n                var accept = options.filter ? options.filter(item) : true;\n                if (accept !== false) {\n                    result.push(item);\n                }\n                return accept;\n            }, options);\n        },\n\n        /**\n         *\n         * Runs a query against the store, but only returns the number of matches\n         * instead of the matches itself.\n         *\n         * @param {Function} onSuccess A callback to be called if the opration\n         *  was successful.\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Function} [options.onError=throw] A callback to be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        count: function (onSuccess, options) {\n\n            options = mixin({\n                index: null,\n                keyRange: null\n            }, options || {});\n\n            var onError = options.onError || defaultErrorHandler;\n\n            var hasSuccess = false,\n                result = null;\n\n            var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            cursorTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            cursorTransaction.onabort = onError;\n            cursorTransaction.onerror = onError;\n\n            var cursorTarget = cursorTransaction.objectStore(this.storeName);\n            if (options.index) {\n                cursorTarget = cursorTarget.index(options.index);\n            }\n            var countRequest = cursorTarget.count(options.keyRange);\n            countRequest.onsuccess = function (evt) {\n                hasSuccess = true;\n                result = evt.target.result;\n            };\n            countRequest.onError = onError;\n\n            return cursorTransaction;\n        },\n\n        /**************/\n        /* key ranges */\n        /**************/\n\n        /**\n         * Creates a key range using specified options. This key range can be\n         * handed over to the count() and iterate() methods.\n         *\n         * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n         *\n         * @param {Object} options The options for the key range to create\n         * @param {*} [options.lower] The lower bound\n         * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n         *  bound passed in options.lower from the key range\n         * @param {*} [options.upper] The upper bound\n         * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n         *  bound passed in options.upper from the key range\n         * @param {*} [options.only] A single key value. Use this if you need a key\n         *  range that only includes one value for a key. Providing this\n         *  property invalidates all other properties.\n         * @return {IDBKeyRange} The IDBKeyRange representing the specified options\n         */\n        makeKeyRange: function (options) {\n            /*jshint onecase:true */\n            var keyRange,\n                hasLower = typeof options.lower != 'undefined',\n                hasUpper = typeof options.upper != 'undefined',\n                isOnly = typeof options.only != 'undefined';\n\n            switch (true) {\n                case isOnly:\n                    keyRange = this.keyRange.only(options.only);\n                    break;\n                case hasLower && hasUpper:\n                    keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n                    break;\n                case hasLower:\n                    keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n                    break;\n                case hasUpper:\n                    keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n                    break;\n                default:\n                    throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n            }\n\n            return keyRange;\n\n        }\n\n    };\n\n    /** helpers **/\n    var empty = {};\n\n    function mixin (target, source) {\n        var name, s;\n        for (name in source) {\n            s = source[name];\n            if (s !== empty[name] && s !== target[name]) {\n                target[name] = s;\n            }\n        }\n        return target;\n    }\n\n    IDBStore.prototype = proto;\n    IDBStore.version = proto.version;\n\n    return IDBStore;\n\n}, this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/idb-wrapper/idbstore.js\n ** module id = 13\n ** module chunks = 1\n **/","(function () {\r\n  /* global self:false, require:false, fetch:false */\r\n\r\n  'use strict'\r\n\r\n  const msgr = require('msgr')\r\n  const IDBStore = require('idb-wrapper')\r\n  const serialiseRequest = require('serialise-request')\r\n  const serialiseResponse = require('serialise-response')\r\n\r\n  const store = new IDBStore({\r\n    dbVersion: 1,\r\n    keyPath: 'id',\r\n    storePrefix: 'fetchSyncs/',\r\n    storeName: 'syncs'\r\n  })\r\n\r\n  const channel = msgr.worker({\r\n    // On get syncs, respond with all operations in the store\r\n    GET_SYNCS: (_, respond) => {\r\n      pify(store.getAll)()\r\n        .then(...responders(respond))\r\n    },\r\n    // On register, register a sync with worker and then add to store\r\n    REGISTER_SYNC: (sync, respond) => {\r\n      registerSync(sync)\r\n        .then(() => addSync(sync))\r\n        .then(...responders(respond))\r\n    },\r\n    // On cancel, remove the sync from store\r\n    CANCEL_SYNC: (id, respond) => {\r\n      pify(store.remove)(id)\r\n        .then(...responders(respond))\r\n    },\r\n    // On cancel all, remove all syncs from store\r\n    CANCEL_ALL_SYNCS: (_, respond) => {\r\n      pify(store.getAll)()\r\n        .then((syncs) => syncs.map((sync) => sync.id))\r\n        .then((ids) => pify(store.removeBatch)(ids))\r\n        .then(...responders(respond))\r\n    }\r\n  })\r\n\r\n  function pify (method) {\r\n    return (...args) => new Promise(method.bind(store, ...args))\r\n  }\r\n\r\n  function responders (respond) {\r\n    return [respond, (e) => respond({ error: e.message })]\r\n  }\r\n\r\n  function registerSync (sync) {\r\n    return self\r\n      .registration['sync']\r\n      .register(sync.id)\r\n  }\r\n\r\n  function addSync (sync) {\r\n    return pify(store.put)(sync).then(null, (err) => {\r\n      if (!/key already exists/.test(err.message)) {\r\n        throw err\r\n      }\r\n    })\r\n  }\r\n\r\n  function syncEvent (event) {\r\n    event.waitUntil(pify(store.get)(event.tag).then((sync) => {\r\n      if (!sync) {\r\n        event.registration && event.registration.unregister()\r\n        store.remove(event.tag)\r\n        return\r\n      }\r\n\r\n      const id = sync.id\r\n      const syncedOn = Date.now()\r\n\r\n      return fetch(serialiseRequest.deserialise(sync.request))\r\n        .then(serialiseResponse)\r\n        .then((response) => {\r\n          const updatedSync = { ...sync, response, syncedOn }\r\n          channel.send('SYNC_RESULT', { id, syncedOn, response })\r\n          if (!updatedSync.name) store.remove(id)\r\n          else store.put(updatedSync)\r\n        })\r\n    }))\r\n  }\r\n\r\n  // The 'sync' event fires when connectivity is\r\n  // restored or already available to the UA.\r\n  self.addEventListener('sync', syncEvent)\r\n\r\n  // The 'activate' event is fired when the service worker becomes operational.\r\n  // For example, after a refresh after install, or after all pages using\r\n  // the older version of the worker have closed after upgrade of the worker.\r\n  self.addEventListener('activate', (event) => event.waitUntil(self.clients.claim()))\r\n\r\n  // The 'install' event is fired when the service worker has been installed.\r\n  // This does not mean that the service worker is operating, as the UA will wait\r\n  // for all pages to close that are using older versions of the worker.\r\n  self.addEventListener('install', (event) => event.waitUntil(self.skipWaiting()))\r\n})()\r\n\n\n\n/** WEBPACK FOOTER **\n ** C:/xampp/htdocs/fetch-sync/src/worker.js\n **/"],"sourceRoot":""}